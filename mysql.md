```
MySQL 隔離級別有以下幾種：

讀未提交（Read Uncommitted）
  最低的隔離級別，允許讀取其他事務尚未提交的變更，可能導致髒讀（Dirty Read）。
  效能：
    效能最高，因為不需要加鎖。
    不會阻止其他事務讀取或修改相同的數據。
  是否鎖資料：
    不會鎖資料，但可能導致脏讀。
  適用場景：
    不需要數據一致性保證，且追求極高的效能，如簡單的數據分析場景。

讀已提交（Read Committed）
  保證只能讀取其他事務已提交的數據，避免髒讀，但可能出現不可重複讀（Non-repeatable Read）。
  效能：
    相對較高，避免了脏讀，但開銷低於更高隔離級別。
    只需在讀取數據時獲取共享鎖（讀鎖），在修改時加排他鎖（寫鎖）。
  是否鎖資料：
    部分鎖資料：
    讀操作：不會長時間鎖定資料，但會在讀時短暫加共享鎖。
    寫操作：修改時會加排他鎖。
  適用場景：
    大部分日常應用的理想選擇，如 OLTP 系統。

可重複讀（Repeatable Read）
  保證同一事務內多次讀取相同數據的結果一致，避免髒讀與不可重複讀，但可能出現幻讀（Phantom Read）。
  MySQL InnoDB 的默認隔離級別。
  效能：
    效能略低於 READ COMMITTED，因為需要維持一致性快照來避免不可重複讀。
    MySQL 使用 間隙鎖（gap locks）來防止幻讀，可能導致更多鎖競爭。
  是否鎖資料：
    會鎖資料：
    讀操作：會在查詢範圍內加共享鎖，並可能加間隙鎖。
    寫操作：會加排他鎖並防止其他事務插入新記錄。
  適用場景：
    MySQL InnoDB 的默認隔離級別，適合需要數據一致性但又需要一定性能的場景。

可序列化（Serializable）
  最高的隔離級別，通過強制事務順序執行，完全避免髒讀、不可重複讀與幻讀，但可能大幅降低並發性能。
  效能：
    效能最差，因為所有操作都會被序列化，導致並發性能大幅下降。
    每次查詢都需要加鎖，極大地增加了系統開銷。
  是否鎖資料：
    會鎖資料：
    讀取範圍內的所有數據都會被鎖定，防止其他事務插入或修改。
  適用場景：
    極端情況下需要強一致性的場景，如財務系統。

[Transaction 併發錯誤與隔離層級](https://oldmo860617.medium.com/transaction-%E4%BD%B5%E7%99%BC%E9%8C%AF%E8%AA%A4%E8%88%87%E9%9A%94%E9%9B%A2%E5%B1%A4%E7%B4%9A-51b8af6178ae)

```
```
效能與鎖定的綜合比較
| 隔離級別            | 效能 | 是否鎖資料             |  特點 |
| READ UNCOMMITTED   | 最高 | 不鎖資料               |  無一致性保證，適合快速讀取需求。
| READ COMMITTED     | 高   | 部分鎖資料             |  避免脏讀，適合大多數應用場景。
| REPEATABLE READ    | 中   | 會鎖資料（含間隙鎖）    |  避免脏讀與不可重複讀，是 MySQL 默認選擇。
| SERIALIZABLE       | 低   | 會鎖資料（讀寫都鎖）    |  強一致性，但效能低，僅適用於特殊場景。

如果需要最高效能且對一致性要求不高，選擇 READ UNCOMMITTED 或 READ COMMITTED。
如果需要一致性（避免不可重複讀或幻讀），選擇 REPEATABLE READ。
只有在需要強一致性保證的情況下（如金融交易），才考慮 SERIALIZABLE。
```

```
共享鎖 (Shared Lock, S)
  用途：允許多個讀取操作（SELECT）同時進行，但阻止數據的寫入操作。
  特點：
  其他事務可以同時加共享鎖。
  只有當共享鎖釋放後，才能加排他鎖。

排他鎖 (Exclusive Lock, X)
  用途：確保事務對數據的寫入（INSERT、UPDATE、DELETE）是唯一的，防止其他事務同時讀取或寫入。
  特點：
  一次只能由一個事務持有排他鎖。
  排他鎖會阻塞其他共享鎖和排他鎖的請求。

意向鎖 (Intent Lock, IS/IX)
  用途：用於多層級鎖定（如表級和行級鎖）之間的協調。
  分類：
  意向共享鎖 (Intent Shared, IS)：表明事務將對某些行加共享鎖。
  意向排他鎖 (Intent Exclusive, IX)：表明事務將對某些行加排他鎖。
  特點：
  幫助資料庫快速檢查是否可以對整個表加鎖。

更新鎖 (Update Lock, U)
  用途：避免因為升級鎖（從共享鎖到排他鎖）導致的死鎖。
  特點：
  允許讀取，但阻止其他更新鎖和排他鎖。
  當需要寫入時，可以升級為排他鎖。

行級鎖 (Row-Level Lock)
  用途：僅對單行資料加鎖，適合高並發場景。
  特點：
  比表級鎖（Table Lock）粒度小，並發性能高。
  分為共享和排他兩種類型。

表級鎖 (Table-Level Lock)
  用途：對整個表加鎖，適合批量操作或防止其他事務對表的訪問。
  分類：
  共享表級鎖 (Shared Table Lock)：允許其他讀取，但阻止寫入。
  排他表級鎖 (Exclusive Table Lock)：完全鎖住整個表，阻止其他操作。

死鎖預防機制的鎖
  意向鎖（如上述 IS/IX）。
  等待鎖 (Wait Lock)：允許事務等待其他事務釋放鎖。
  超時鎖 (Timeout Lock)：設置等待鎖的超時時間，避免無限等待。

事務鎖 (Transaction Locks)
  用途：針對事務進行的操作進行保護，主要包括：
  悲觀鎖 (Pessimistic Lock)：通過鎖機制避免並發衝突，實時鎖定資源。
  樂觀鎖 (Optimistic Lock)：不使用實際的資料庫鎖，而是通過版本號或時間戳檢查並發問題。

其他特定類型的鎖
Gap Lock (間隙鎖)
  用途：防止幻讀問題（Phantom Read）。
  特點：
  鎖住範圍內的索引「間隙」，而不僅是具體的行。

Next-Key Lock
  用途：結合行鎖和間隙鎖，防止幻讀。
  特點：
  鎖住匹配行及其間隙。


鎖類型	          用途	              特點
共享鎖(S)	    | 保護讀取操作	      | 允許多事務同時讀取，禁止寫入
排他鎖(X)	    | 保護寫入操作	      | 寫操作唯一持有，禁止其他讀/寫
意向鎖(IS/IX)	| 多層級鎖協調	      | 快速檢查是否可加鎖
更新鎖(U)	    | 鎖升級時避免死鎖	  | 可升級為排他鎖
Gap Lock      | 防止幻讀	          | 鎖住間隙，而非具體行
悲觀鎖         | 實時加鎖以避免衝突 | 通常基於資料庫原生鎖
樂觀鎖	        | 檢查版本號避免衝突  | 不依賴資料庫鎖，效率高

```
